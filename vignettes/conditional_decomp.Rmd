---
title: "A conditional decomposition of the Brier score"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{A conditional decomposition of the Brier score}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ConditionalScoreDecomp)
library(reliabilitydiag)
library(mapproj)
```

```{r function}
# function to plot decomposition terms against lead time
plot_vs_lt <- function(threshold, method = "COSMO", states, unconditional = T){
  
  if(unconditional){
    if(method == "COSMO"){
      p_decomp <- sapply(1:n_lt, function(lt){
        ts_y <- as.numeric(ts_obs[lt, ] > threshold)
        pEns <- get_ens_probability(ts_fcst, lt, threshold)
        bs_decomp(pEns, ts_y)*sc 
      }) # raw ensemble
    }else if(method == "clim"){
      p_decomp <- sapply(1:n_lt, function(lt){
        ts_y <- as.numeric(ts_obs[lt, ] > threshold)
        pClim <- get_clim_probability(tr_obs[1, ], n_test, threshold, disc_fcsts = discrete_fcsts)
        bs_decomp(pClim, ts_y)*sc 
      }) # climatology
    }else if(method == "cond_clim"){
      p_decomp <- sapply(1:n_lt, function(lt){
        ts_y <- as.numeric(ts_obs[lt, ] > threshold)
        pClim_cond <- get_clim_probability(tr_obs[1, ], n_test, threshold, disc_fcsts = discrete_fcsts, states = states)
        bs_decomp(pClim_cond, ts_y)*sc 
      }) # conditional climatology
    }else if(method == "post-proc"){
      p_decomp <- sapply(1:n_lt, function(lt){
        tr_y <- as.numeric(tr_obs[lt, ] > threshold)
        ts_y <- as.numeric(ts_obs[lt, ] > threshold)
        pPP <- get_pp_probability(tr_y, ts_y, tr_fcst, ts_fcst, lt, threshold, disc_fcsts = discrete_fcsts)
        bs_decomp(pPP, ts_y)*sc 
      }) # post-processed
    }else if(method == "cond_post-proc"){
      p_decomp <- sapply(1:n_lt, function(lt){
        tr_y <- as.numeric(tr_obs[lt, ] > threshold)
        ts_y <- as.numeric(ts_obs[lt, ] > threshold)
        pPP_cond <- get_pp_probability(tr_y, ts_y, tr_fcst, ts_fcst, lt, threshold, disc_fcsts = discrete_fcsts, states = states)
        bs_decomp(pPP_cond, ts_y)*sc 
      }) # conditional post-processed
    }
    
    df <- data.frame(lead = rep(1:n_lt, each = 4), term = rep(c("UNC", "RES", "REL", " Tot"), n_lt),
                     s = as.vector(p_decomp))
    ggplot(df) + geom_line(aes(x = lead, y = s, col = term), size = 1) + 
      geom_hline(aes(yintercept = 0), lty = "dotted") + ylim(c(0, 2500)) +    
      scale_y_continuous(name = "") +
      scale_x_continuous(name = "Lead time (days)") +
      scale_color_manual(values = c("black", "#619CFF", "#00BA38", "#F8766D"), 
                         labels = c("Tot", expression(REL[F]), expression(RES[F]), expression(UNC[Y]))) +
      theme_bw() + theme(legend.title = element_blank(), legend.position = "bottom")
  }else{
  if(method == "COSMO"){
    p_decomp <- sapply(1:n_lt, function(lt){
      ts_y <- as.numeric(ts_obs[lt, ] > threshold)
      pEns <- get_ens_probability(ts_fcst, lt, threshold)
      bs_decomp(pEns, ts_y, states$ts)*sc 
    }) # raw ensemble
  }else if(method == "clim"){
    p_decomp <- sapply(1:n_lt, function(lt){
      ts_y <- as.numeric(ts_obs[lt, ] > threshold)
      pClim <- get_clim_probability(tr_obs[1, ], n_test, threshold, disc_fcsts = discrete_fcsts)
      bs_decomp(pClim, ts_y, states$ts)*sc
    }) # climatology
  }else if(method == "cond_clim"){
    p_decomp <- sapply(1:n_lt, function(lt){
      ts_y <- as.numeric(ts_obs[lt, ] > threshold)
      pClim_cond <- get_clim_probability(tr_obs[1, ], n_test, threshold, disc_fcsts = discrete_fcsts, states = states)
      bs_decomp(pClim_cond, ts_y, states$ts)*sc
    }) # conditional climatology
  }else if(method == "post-proc"){
    p_decomp <- sapply(1:n_lt, function(lt){
      tr_y <- as.numeric(tr_obs[lt, ] > threshold)
      ts_y <- as.numeric(ts_obs[lt, ] > threshold)
      pPP <- get_pp_probability(tr_y, ts_y, tr_fcst, ts_fcst, lt, threshold, disc_fcsts = discrete_fcsts)
      bs_decomp(pPP, ts_y, states$ts)*sc
    }) # post-processed
  }else if(method == "cond_post-proc"){
    p_decomp <- sapply(1:n_lt, function(lt){
      tr_y <- as.numeric(tr_obs[lt, ] > threshold)
      ts_y <- as.numeric(ts_obs[lt, ] > threshold)
      pPP_cond <- get_pp_probability(tr_y, ts_y, tr_fcst, ts_fcst, lt, threshold, disc_fcsts = discrete_fcsts, states = states)
      bs_decomp(pPP_cond, ts_y, states$ts)*sc
    }) # conditional post-processed
  }

  df <- data.frame(lead = rep(1:n_lt, each = 6), s = as.vector(p_decomp),
                   term = rep(c("UNC_Y|A", "RES_A", "RES_F|A", "RES_A|F", "REL_F|A", " Tot"), n_lt))
  ggplot(df) + geom_line(aes(x = lead, y = s, col = term), size = 1) +
    geom_hline(aes(yintercept = 0), lty = "dotted") +
    scale_y_continuous(name = "", limits = c(0, 2500)) +
    scale_x_continuous(name = "Lead time (days)") + 
    scale_color_manual(values = c("black", "#D39200", "#00C19F", "#DB72FB", "#93AA00", "#00B9E3"), 
                       labels = c("Tot      ", expression(REL["F|A"]), expression(RES[A  ]),
                                  expression(RES["A|F"]),
                                  expression(RES["F|A"]), expression(UNC["Y|A"]))) +
    theme_bw() + theme(legend.title = element_blank(), legend.position = "bottom")
  }
}


# function to plot decomposition terms against threshold
plot_vs_t <- function(threshold_vec, lead, method = "COSMO", states, unconditional = T){
  
  if(unconditional){
    if(method == "COSMO"){
      p_decomp <- sapply(seq_along(threshold_vec), function(i){
        ts_y <- as.numeric(ts_obs[lead, ] > threshold_vec[i])
        pEns <- get_ens_probability(ts_fcst, lead, threshold_vec[i])
        bs_decomp(pEns, ts_y)*sc
      }) # raw ensemble
    }else if(method == "clim"){
      p_decomp <- sapply(seq_along(threshold_vec), function(i){
        ts_y <- as.numeric(ts_obs[lead, ] > threshold_vec[i])
        pClim <- get_clim_probability(tr_obs[1, ], n_test, threshold_vec[i], disc_fcsts = discrete_fcsts)
        bs_decomp(pClim, ts_y)*sc
      }) # climatology
    }else if(method == "cond_clim"){
      p_decomp <- sapply(seq_along(threshold_vec), function(i){
        ts_y <- as.numeric(ts_obs[lead, ] > threshold_vec[i])
        pClim_cond <- get_clim_probability(tr_obs[1, ], n_test, threshold_vec[i], disc_fcsts = discrete_fcsts, states = states)
        bs_decomp(pClim_cond, ts_y)*sc
      }) # conditional climatology
    }else if(method == "post-proc"){
      p_decomp <- sapply(seq_along(threshold_vec), function(i){
        tr_y <- as.numeric(tr_obs[lead, ] > threshold_vec[i])
        ts_y <- as.numeric(ts_obs[lead, ] > threshold_vec[i])
        pPP <- get_pp_probability(tr_y, ts_y, tr_fcst, ts_fcst, lead, threshold_vec[i], disc_fcsts = discrete_fcsts)
        bs_decomp(pPP, ts_y)*sc
      }) # post-processed
    }else if(method == "cond_post-proc"){
      p_decomp <- sapply(seq_along(threshold_vec), function(i){
        tr_y <- as.numeric(tr_obs[lead, ] > threshold_vec[i])
        ts_y <- as.numeric(ts_obs[lead, ] > threshold_vec[i])
        pPP_cond <- get_pp_probability(tr_y, ts_y, tr_fcst, ts_fcst, lead, threshold_vec[i], disc_fcsts = discrete_fcsts, states = states)
        bs_decomp(pPP_cond, ts_y)*sc 
      }) # conditional post-processed
    }
    
    
    df <- data.frame(x = as.vector(p_decomp),  t = rep(threshold_vec, each = 4),
                     y = rep(c("UNC", "RES", "REL", " Tot"), length(threshold_vec)))
    ggplot(df) + geom_line(aes(x = t, y = x, col = y), size = 1) +
      geom_hline(aes(yintercept = 0), lty = "dotted") +
      scale_x_continuous(name = "Threshold (\u00B0C)") +
      scale_y_continuous(name = "", limits = c(0, 2500)) + 
      scale_color_manual(values = c("black", "#619CFF", "#00BA38", "#F8766D"), 
                         labels = c("Tot", expression(REL[F]), expression(RES[F]), expression(UNC[Y]))) +
      theme_bw() + theme(legend.title = element_blank(), legend.position = "bottom") 
      
  }else{
    if(method == "COSMO"){
      p_decomp <- sapply(seq_along(threshold_vec), function(i){
        ts_y <- as.numeric(ts_obs[lead, ] > threshold_vec[i])
        pEns <- get_ens_probability(ts_fcst, lead, threshold_vec[i])
        bs_decomp(pEns, ts_y, states$ts)*sc
      }) # raw ensemble
    }else if(method == "clim"){
      p_decomp <- sapply(seq_along(threshold_vec), function(i){
        ts_y <- as.numeric(ts_obs[lead, ] > threshold_vec[i])
        pClim <- get_clim_probability(tr_obs[1, ], n_test, threshold_vec[i], disc_fcsts = discrete_fcsts)
        bs_decomp(pClim, ts_y, states$ts)*sc
      }) # climatology
    }else if(method == "cond_clim"){
      p_decomp <- sapply(seq_along(threshold_vec), function(i){
        ts_y <- as.numeric(ts_obs[lead, ] > threshold_vec[i])
        pClim_cond <- get_clim_probability(tr_obs[1, ], n_test, threshold_vec[i], disc_fcsts = discrete_fcsts, states = states)
        bs_decomp(pClim_cond, ts_y, states$ts)*sc
      }) # conditional climatology
    }else if(method == "post-proc"){
      p_decomp <- sapply(seq_along(threshold_vec), function(i){
        tr_y <- as.numeric(tr_obs[lead, ] > threshold_vec[i])
        ts_y <- as.numeric(ts_obs[lead, ] > threshold_vec[i])
        pPP <- get_pp_probability(tr_y, ts_y, tr_fcst, ts_fcst, lead, threshold_vec[i], disc_fcsts = discrete_fcsts)
        bs_decomp(pPP, ts_y, states$ts)*sc
      }) # post-processed
    }else if(method == "cond_post-proc"){
      p_decomp <- sapply(seq_along(threshold_vec), function(i){
        tr_y <- as.numeric(tr_obs[lead, ] > threshold_vec[i])
        ts_y <- as.numeric(ts_obs[lead, ] > threshold_vec[i])
        pPP_cond <- get_pp_probability(tr_y, ts_y, tr_fcst, ts_fcst, lead, threshold_vec[i], disc_fcsts = discrete_fcsts, states = states)
        bs_decomp(pPP_cond, ts_y, states$ts)*sc 
      }) # conditional post-processed
    }
    
    df <- data.frame(x = as.vector(p_decomp),  t = rep(threshold_vec, each = 6),
                     y = rep(c("UNC_Y|A", "RES_A", "RES_F|A", "RES_A|F", "REL_F|A", " Tot"),
                             length(threshold_vec)))
    ggplot(df) + geom_line(aes(x = t, y = x, col = y), size = 1) + 
      geom_hline(aes(yintercept = 0), lty = "dotted") +
      scale_x_continuous(name = "Threshold (\u00B0C)") +
      scale_y_continuous(name = "", limits = c(0, 2500)) + 
      scale_color_manual(values = c("black", "#D39200", "#00C19F", "#DB72FB", "#93AA00", "#00B9E3"), 
                         labels = c("Tot      ", expression(REL["F|A"]), expression(RES[A  ]),
                                    expression(RES["A|F"]), expression(RES["F|A"]), expression(UNC["Y|A"]))) +
      theme_bw() + theme(legend.title = element_blank(), legend.position = "bottom")
      
  }
}

# function to estimate confidence regions for skill scores using nonparametric bootstrapping
bss_unc <- function(s, s_ref, N = 1000, level = 0.95){
  n <- length(s)
  ss <- sapply(1:N, function(i){
    ind <- sample(1:n, n, replace = TRUE)
    skill <- 1 - mean(s[ind], na.rm = T)/mean(s_ref[ind], na.rm=T)
    return(skill)
  })
  ss_CI <- quantile(ss, c((1 - level)/2, (1 + level)/2))
  return(unname(ss_CI))
}


# function to estimate confidence regions for decomposition terms using nonparametric bootstrapping
rel_unc <- function(p, o, N = 1000, level = 0.95, states = NULL){
  n <- length(o)
  if(is.null(states)){
    rel <- sapply(1:N, function(i){
      ind <- sample(1:n, n, replace = TRUE)
      terms <- bs_decomp(p[ind], o[ind])
      impr <- terms["REL"]/terms["TOT"]
      return(unname(impr))
    })
  }else{
    rel <- sapply(1:N, function(i){
      ind <- sample(1:n, n, replace = TRUE)
      terms <- bs_decomp_cond(p[ind], o[ind], states = states[ind])
      impr <- terms["RES_A|F"]/terms["TOT"]
      return(unname(impr))
    })
  }
  rel_CI <- quantile(rel, c((1 - level)/2, (1 + level)/2))
  return(unname(rel_CI))
}

# plot improvement gained by the ensemble forecast as a function of threshold
plot_pp_gain <- function(threshold_vec, lead){
  
  ss_CI <- sapply(seq_along(threshold_vec), function(i){
    print(i)
    tr_y <- as.numeric(tr_obs[lead, ] > threshold_vec[i])
    ts_y <- as.numeric(ts_obs[lead, ] > threshold_vec[i])
    pEns <- get_ens_probability(ts_fcst, lead, threshold_vec[i])
    pPP <- get_pp_probability(tr_y, ts_y, tr_fcst, ts_fcst, lead, threshold_vec[i], disc_fcsts = discrete_fcsts)
    
    # ss
    s_ens <- (pEns - ts_y)^2
    s_pp <- (pPP - ts_y)^2
    ss <- 1 - mean(s_pp, na.rm = T)/mean(s_ens, na.rm = T)
    ss_unc <- bss_unc(s_pp, s_ens)
    
    # rel
    impr <- bs_decomp(pEns, ts_y)
    impr <- unname(impr["REL"]/impr["TOT"])
    impr_unc <- rel_unc(pEns, ts_y)
    
    return(c(ss, ss_unc, impr, impr_unc))
  })
  
  df <- data.frame(t = threshold_vec, 
                   x = c(ss_CI[1, ], ss_CI[4, ]),
                   se_low = c(ss_CI[2, ], ss_CI[5, ]),
                   se_high = c(ss_CI[3, ], ss_CI[6, ]),
                   mth = rep(c("Actual", "Theoretical"), each = length(threshold_vec)))
  ggplot(df) + geom_line(aes(x = t, y = x, col = mth), size = 1) + 
    geom_hline(aes(yintercept = 0), lty = "dotted") +
    geom_ribbon(aes(x = t, ymin = se_low, ymax = se_high, fill = mth), alpha = 0.2) +
    scale_x_continuous(name = "Threshold (\u00B0C)") +
    scale_y_continuous(name = "Brier skill score", limits = c(-0.05, 0.35)) + 
    theme_bw() + theme(legend.title = element_blank(), legend.position = "bottom") +
    guides(fill = "none")
}


# plot improvement gained by conditional post-processing as a function of threshold
plot_cond_pp_gain <- function(threshold_vec, lead, states){
  
  ss_CI <- sapply(seq_along(threshold_vec), function(i){
    print(i)
    tr_y <- as.numeric(tr_obs[lead, ] > threshold_vec[i])
    ts_y <- as.numeric(ts_obs[lead, ] > threshold_vec[i])
    pPP <- get_pp_probability(tr_y, ts_y, tr_fcst, ts_fcst, lead, threshold_vec[i], disc_fcsts = discrete_fcsts)
    pPP_cond <- get_pp_probability(tr_y, ts_y, tr_fcst, ts_fcst, lead, threshold_vec[i], disc_fcsts = discrete_fcsts, states = states)
    
    # ss
    s_pp <- (pPP - ts_y)^2
    s_pp_cond <- (pPP_cond - ts_y)^2
    ss <- 1 - mean(s_pp_cond, na.rm = T)/mean(s_pp, na.rm = T)
    ss_unc <- bss_unc(s_pp_cond, s_pp)
    
    # rel
    impr <- bs_decomp(pPP, ts_y, states = states$ts)
    impr <- unname(impr["RES_A|F"]/impr["TOT"])
    impr_unc <- rel_unc(pPP, ts_y, states = states$ts)
    
    return(c(ss, ss_unc, impr, impr_unc))
  })
  
  df <- data.frame(t = threshold_vec, 
                   x = c(ss_CI[1, ], ss_CI[4, ]),
                   se_low = c(ss_CI[2, ], ss_CI[5, ]),
                   se_high = c(ss_CI[3, ], ss_CI[6, ]),
                   mth = rep(c("Actual", "Theoretical"), each = length(threshold_vec)))
  ggplot(df) + geom_line(aes(x = t, y = x, col = mth), size = 1) +
    geom_hline(aes(yintercept = 0), lty = "dotted") +
    geom_ribbon(aes(x = t, ymin = se_low, ymax = se_high, fill = mth), alpha = 0.2) +
    scale_x_continuous(name = "Threshold (\u00B0C)") +
    scale_y_continuous(name = "Brier skill score", limits = c(-0.05, 0.35)) +
    theme_bw() + theme(legend.title = element_blank(), legend.position = "bottom") +
    guides(fill = "none")
}
```
